#!/usr/bin/env node
/**
 * Bitcoin9to5 Setup Wizard - Interactive TUI
 *
 * Interactive CLI to help users:
 * 1. Configure environment variables
 * 2. Run backtests to find optimal parameters
 * 3. Understand the strategy
 * 4. Start the bot
 *
 * Usage: node scripts/wizard.js
 */

import { readFileSync, writeFileSync, existsSync } from 'fs'
import { select, input, confirm, password } from '@inquirer/prompts'
import chalk from 'chalk'
import ora from 'ora'
import { spawn } from 'child_process'
import { dirname, join } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const ROOT_DIR = join(__dirname, '..')

// Header art
const HEADER = `
${chalk.cyan('  ╔══════════════════════════════════════════════════════════╗')}
${chalk.cyan('  ║')}${chalk.bold.white('            BITCOIN 9-TO-5 TRADING BOT                  ')}${chalk.cyan('║')}
${chalk.cyan('  ║')}${chalk.gray('         Perpetual Futures on Nado Exchange              ')}${chalk.cyan('║')}
${chalk.cyan('  ╚══════════════════════════════════════════════════════════╝')}
`

const DIVIDER = chalk.gray('  ─────────────────────────────────────────────────────────')

// Check if .env file exists and has PRIVATE_KEY
function checkEnvFile() {
  const envPath = join(ROOT_DIR, '.env')
  if (!existsSync(envPath)) {
    return { exists: false, hasKey: false }
  }
  const content = readFileSync(envPath, 'utf8')
  const hasKey = content.includes('PRIVATE_KEY=') && !content.includes('PRIVATE_KEY=your_')
  return { exists: true, hasKey, content }
}

// Create or update .env file
function writeEnvFile(privateKey) {
  const envPath = join(ROOT_DIR, '.env')
  const content = `# Bitcoin9to5 Bot Configuration
# Generated by setup wizard

# Your Ethereum private key (with 0x prefix)
# This is used to sign transactions on Nado/Ink
PRIVATE_KEY=${privateKey}
`
  writeFileSync(envPath, content)
}

// Run a command with spinner or streaming output
function runCommand(cmd, args, options = {}) {
  return new Promise((resolve, reject) => {
    const proc = spawn(cmd, args, {
      cwd: ROOT_DIR,
      ...options
    })

    let stdout = ''
    let stderr = ''

    if (proc.stdout) {
      proc.stdout.on('data', data => {
        stdout += data.toString()
        if (options.stream) process.stdout.write(data)
      })
    }

    if (proc.stderr) {
      proc.stderr.on('data', data => {
        stderr += data.toString()
        if (options.stream) process.stderr.write(data)
      })
    }

    proc.on('close', code => {
      resolve({ code, stdout, stderr })
    })

    proc.on('error', reject)
  })
}

// Print header
function printHeader(subtitle = '') {
  console.clear()
  console.log(HEADER)
  if (subtitle) {
    console.log(chalk.bold.white(`  ${subtitle}\n`))
    console.log(DIVIDER + '\n')
  }
}

// Print strategy overview
function printStrategyOverview() {
  console.log(`
  ${chalk.yellow('Premise:')} BTC tends to drop during US market hours
           and rise overnight/weekends.

  ${chalk.green.bold('Long Zone')}  ${chalk.gray('(overnight, weekends, holidays)')}
    ${chalk.gray('→')} Bot goes ${chalk.green('LONG')}, expecting price to rise
    ${chalk.gray('→')} Default: 4:01 PM - 9:29 AM ET

  ${chalk.red.bold('Short Zone')} ${chalk.gray('(US market hours, weekdays)')}
    ${chalk.gray('→')} Bot goes ${chalk.red('SHORT')}, expecting price to drop
    ${chalk.gray('→')} Default: 9:29 AM - 4:01 PM ET

  ${chalk.cyan.bold('Profit Taking')}
    ${chalk.gray('→')} Closes at 1% price move (~10% PnL at 10x)
    ${chalk.gray('→')} Trailing stop protects gains in TP zone
`)
}

// Main menu
async function mainMenu() {
  printHeader()

  const choice = await select({
    message: 'What would you like to do?',
    choices: [
      {
        name: `${chalk.green('Quick Start')}     Set up and run the bot`,
        value: 'quickstart'
      },
      {
        name: `${chalk.blue('Run Backtest')}    Test strategy on historical data`,
        value: 'backtest'
      },
      {
        name: `${chalk.magenta('Optimize')}        Find optimal parameters`,
        value: 'optimize'
      },
      {
        name: `${chalk.cyan('Learn Strategy')}  Understand how the bot works`,
        value: 'learn'
      },
      {
        name: `${chalk.yellow('Check Status')}    View current position & config`,
        value: 'status'
      },
      {
        name: `${chalk.red('Exit')}`,
        value: 'exit'
      }
    ],
    theme: {
      prefix: '  ',
      style: {
        highlight: (text) => chalk.cyan.bold(text)
      }
    }
  })

  return choice
}

// Quick start flow
async function quickStart() {
  printHeader('QUICK START GUIDE')

  // Step 1: Check dependencies
  console.log(`  ${chalk.cyan('Step 1:')} Checking dependencies...`)
  const spinner = ora({ text: 'Checking npm packages...', indent: 4 }).start()

  const { code } = await runCommand('npm', ['list', '--depth=0'])
  if (code !== 0) {
    spinner.text = 'Installing dependencies...'
    await runCommand('npm', ['install'])
  }
  spinner.succeed('Dependencies OK')
  console.log('')

  // Step 2: Check/setup private key
  console.log(`  ${chalk.cyan('Step 2:')} Configuring wallet...`)
  const envStatus = checkEnvFile()

  if (envStatus.hasKey) {
    console.log(`  ${chalk.green('✓')} Private key already configured\n`)
  } else {
    console.log('')
    console.log(chalk.yellow('  ⚠️  Private key required\n'))
    console.log('  Your Ethereum private key is needed to sign transactions.')
    console.log('  It will be stored locally in .env (gitignored).\n')
    console.log(chalk.gray('  Format: 0x followed by 64 hex characters'))
    console.log(chalk.gray('  Example: 0x1234...abcd\n'))

    const key = await password({
      message: 'Enter your private key:',
      mask: '*',
      theme: { prefix: '  ' }
    })

    if (!key.startsWith('0x') || key.length !== 66) {
      console.log(chalk.red('\n  ✗ Invalid key format. Should be 0x + 64 hex chars'))
      await pressEnterToContinue()
      return
    }

    writeEnvFile(key)
    console.log(`  ${chalk.green('✓')} Private key saved to .env\n`)
  }

  // Step 3: Recommend running backtest
  console.log(`  ${chalk.cyan('Step 3:')} Verify strategy with backtest\n`)
  console.log('  Before running live, we recommend backtesting to:')
  console.log(`    ${chalk.gray('•')} Verify the strategy works with current market data`)
  console.log(`    ${chalk.gray('•')} Understand expected returns and drawdowns`)
  console.log(`    ${chalk.gray('•')} Find optimal parameters for your risk tolerance\n`)

  const runBacktest = await confirm({
    message: 'Run quick backtest?',
    default: true,
    theme: { prefix: '  ' }
  })

  if (runBacktest) {
    console.log('\n  Running 30-day backtest...\n')
    console.log(DIVIDER + '\n')

    const result = await runCommand('node', ['backtest/test-local.js'], { stream: true })

    if (result.code !== 0) {
      console.log(chalk.yellow('\n  Backtest completed with synthetic data'))
      console.log(chalk.gray('  (Real Binance data requires network access)\n'))
    }
  }

  // Step 4: Final confirmation
  console.log(DIVIDER + '\n')
  console.log(`  ${chalk.cyan('Step 4:')} Ready to start!\n`)
  console.log('  The bot will:')
  console.log(`    ${chalk.gray('•')} Connect to Nado exchange on Ink L2`)
  console.log(`    ${chalk.gray('•')} Monitor BTC perpetual futures`)
  console.log(`    ${chalk.gray('•')} Trade based on time-of-day zones`)
  console.log(`    ${chalk.gray('•')} Take profits at 1% price moves\n`)

  console.log(chalk.yellow('  Commands:'))
  console.log(`    Start:  ${chalk.bold('PRIVATE_KEY="0x..." node bot.js')}`)
  console.log(`    Stop:   ${chalk.bold('Ctrl+C')}`)
  console.log(`    Close:  ${chalk.bold('node bot.js --close')} (close any position)\n`)

  const startNow = await confirm({
    message: 'Start bot now?',
    default: false,
    theme: { prefix: '  ' }
  })

  if (startNow) {
    console.log('\n  Starting bot...\n')
    console.log(DIVIDER + '\n')

    const { hasKey } = checkEnvFile()
    if (!hasKey) {
      console.log(chalk.red('  ✗ No private key found. Please set PRIVATE_KEY in .env'))
      await pressEnterToContinue()
      return
    }

    await runCommand('node', ['bot.js'], { stream: true, stdio: 'inherit' })
  }

  await pressEnterToContinue()
}

// Run backtest menu
async function runBacktestMenu() {
  printHeader('BACKTEST CONFIGURATION')

  console.log('  Data source: Binance BTCUSDT Perpetual Futures')
  console.log('  Interval: 5-minute candles (default)\n')

  const days = await input({
    message: 'Days of history:',
    default: '30',
    theme: { prefix: '  ' }
  })

  const showTrades = await confirm({
    message: 'Show individual trades?',
    default: false,
    theme: { prefix: '  ' }
  })

  const noCosts = await confirm({
    message: 'Exclude trading costs?',
    default: false,
    theme: { prefix: '  ' }
  })

  let args = ['backtest/run.js', '--days', days]

  if (showTrades) args.push('--trades')
  if (noCosts) args.push('--no-costs')

  console.log('\n  Running backtest...\n')
  console.log(DIVIDER + '\n')

  const spinner = ora({ text: 'Fetching historical data...', indent: 2 }).start()
  spinner.stop()

  const result = await runCommand('node', args, { stream: true })

  if (result.code !== 0) {
    console.log(chalk.yellow('\n  Network error - running local test instead...\n'))
    await runCommand('node', ['backtest/test-local.js'], { stream: true })
  }

  await pressEnterToContinue()
}

// Optimize parameters menu
async function optimizeMenu() {
  printHeader('PARAMETER OPTIMIZATION')

  console.log('  Find optimal parameters via grid search.\n')

  const choice = await select({
    message: 'What to optimize?',
    choices: [
      {
        name: `${chalk.cyan('Profit Target')}   Optimize take-profit percentage`,
        value: 'profit'
      },
      {
        name: `${chalk.cyan('Zone Times')}      Find best entry/exit times`,
        value: 'zone'
      },
      {
        name: `${chalk.cyan('Full Grid')}       Search all parameters`,
        value: 'full'
      },
      {
        name: `${chalk.gray('Back to menu')}`,
        value: 'back'
      }
    ],
    theme: {
      prefix: '  ',
      style: {
        highlight: (text) => chalk.cyan.bold(text)
      }
    }
  })

  if (choice === 'back') return

  let args = ['backtest/optimize.js']

  switch (choice) {
    case 'profit':
      args.push('--param', 'profitTarget', '--range', '0.5,2.0,0.25')
      break
    case 'zone':
      args.push('--param', 'shortStart', '--range', '8,11,0.5')
      break
    case 'full':
      args.push('--multi')
      break
  }

  const days = await input({
    message: 'Days of data:',
    default: '30',
    theme: { prefix: '  ' }
  })
  args.push('--days', days)

  console.log('\n  Running optimization...\n')
  console.log(DIVIDER + '\n')

  const result = await runCommand('node', args, { stream: true })

  if (result.code !== 0) {
    console.log(chalk.yellow('\n  Optimization requires network access to Binance'))
  }

  await pressEnterToContinue()
}

// Learn strategy
async function learnStrategy() {
  printHeader('STRATEGY OVERVIEW')

  printStrategyOverview()

  console.log(chalk.bold.white('  KEY PARAMETERS\n'))
  console.log(DIVIDER + '\n')

  const params = [
    ['Profit Target', '1.0% price move'],
    ['Leverage', '10x'],
    ['Expected PnL', '~10% per winning trade'],
    ['Trailing Stop', '0.5% (in TP zone)'],
    ['TP Zone Threshold', '6 hours until short zone']
  ]

  for (const [key, val] of params) {
    console.log(`  ${chalk.cyan(key + ':')}${' '.repeat(20 - key.length)}${val}`)
  }

  console.log('')
  console.log(chalk.bold.white('  RISK MANAGEMENT\n'))
  console.log(DIVIDER + '\n')

  const risks = [
    'Use Kelly Criterion to size positions',
    'Half-Kelly recommended for safety',
    'Never risk more than you can afford to lose',
    'Backtest before going live',
    'Start with small position sizes'
  ]

  for (const risk of risks) {
    console.log(`  ${chalk.gray('•')} ${risk}`)
  }

  console.log('')
  console.log(chalk.bold.white('  TRADING COSTS (Nado)\n'))
  console.log(DIVIDER + '\n')

  console.log(`  ${chalk.yellow('Taker Fee:')}    5.0 bps (0.05%) - base tier`)
  console.log(`  ${chalk.yellow('Slippage:')}     ~5.0 bps estimated`)
  console.log(`  ${chalk.yellow('Funding:')}      ~1.0 bps per 8h`)
  console.log('')
  console.log(chalk.gray('  Volume discounts available at higher tiers (down to 1.5 bps)\n'))

  await pressEnterToContinue()
}

// Check status
async function checkStatus() {
  printHeader('CURRENT STATUS')

  // Check bot state file
  const statePath = join(ROOT_DIR, '.bot-state.json')
  if (existsSync(statePath)) {
    try {
      const state = JSON.parse(readFileSync(statePath, 'utf8'))
      console.log(`  ${chalk.cyan('Bot State:')}`)
      const zoneColor = state.zone === 'long' ? chalk.green : chalk.red
      console.log(`    Zone:        ${zoneColor(state.zone.toUpperCase())}`)
      console.log(`    Entry Price: ${state.entryPrice ? `$${state.entryPrice.toFixed(2)}` : chalk.gray('None')}`)
      console.log(`    TP Zone:     ${state.inTpZone ? chalk.green('Active') : chalk.gray('Inactive')}`)
      if (state.tpZonePeakPrice) {
        console.log(`    Peak Price:  $${state.tpZonePeakPrice.toFixed(2)}`)
      }
      console.log('')
    } catch {
      console.log(`  ${chalk.yellow('Could not read bot state')}`)
    }
  } else {
    console.log(`  ${chalk.gray('No bot state found (bot not running)')}\n`)
  }

  // Check zone config
  const configPath = join(ROOT_DIR, '.zone-config.json')
  if (existsSync(configPath)) {
    try {
      const config = JSON.parse(readFileSync(configPath, 'utf8'))
      console.log(`  ${chalk.cyan('Zone Configuration:')}`)
      console.log(`    Short Zone:  ${config.flipToShortReadable || '9:29'} - ${config.flipToLongReadable || '16:01'} ET`)
      console.log(`    Last Update: ${config.updatedAt || chalk.gray('Never')}`)
      console.log('')
    } catch {
      console.log(`  ${chalk.yellow('Could not read zone config')}`)
    }
  }

  // Check env
  const envStatus = checkEnvFile()
  console.log(`  ${chalk.cyan('Environment:')}`)
  console.log(`    Private Key: ${envStatus.hasKey ? chalk.green('Configured') : chalk.red('Not set')}`)
  console.log('')

  // Determine current zone
  const now = new Date()
  const etHour = now.getUTCHours() - 5
  const etMin = now.getUTCMinutes()
  const dayOfWeek = now.getUTCDay()

  let currentZone = 'long'
  if (dayOfWeek >= 1 && dayOfWeek <= 5) {
    const afterOpen = etHour > 9 || (etHour === 9 && etMin >= 29)
    const beforeClose = etHour < 16 || (etHour === 16 && etMin < 1)
    if (afterOpen && beforeClose) currentZone = 'short'
  }

  const zoneColor = currentZone === 'long' ? chalk.green : chalk.red
  console.log(`  ${chalk.cyan('Current Time:')}`)
  console.log(`    ET:          ${(etHour + 24) % 24}:${String(etMin).padStart(2, '0')}`)
  console.log(`    Zone:        ${zoneColor(currentZone.toUpperCase())}`)
  console.log('')

  await pressEnterToContinue()
}

// Helper to wait for user
async function pressEnterToContinue() {
  await input({
    message: 'Press Enter to continue...',
    theme: { prefix: '  ' }
  })
}

// Main loop
async function main() {
  while (true) {
    try {
      const choice = await mainMenu()

      switch (choice) {
        case 'quickstart':
          await quickStart()
          break
        case 'backtest':
          await runBacktestMenu()
          break
        case 'optimize':
          await optimizeMenu()
          break
        case 'learn':
          await learnStrategy()
          break
        case 'status':
          await checkStatus()
          break
        case 'exit':
          console.log(chalk.cyan('\n  Goodbye!\n'))
          process.exit(0)
      }
    } catch (err) {
      // Handle Ctrl+C gracefully
      if (err.name === 'ExitPromptError') {
        console.log(chalk.cyan('\n  Goodbye!\n'))
        process.exit(0)
      }
      throw err
    }
  }
}

// Handle clean exit
process.on('SIGINT', () => {
  console.log(chalk.cyan('\n\n  Goodbye!\n'))
  process.exit(0)
})

main().catch(err => {
  console.error('Wizard error:', err)
  process.exit(1)
})
